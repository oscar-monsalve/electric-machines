import numpy as np
import cmath

import functions as fn


# Exercise data

# Motor data
line_voltage = 440  # V
field_rpm = 1800
fp = 0.8

# Resistances (Ohm)
r_1 = 1.5
r_2 = 1.2
r_m = 900

# Reactances
jx = complex(0, 6)  # total
jx_m = complex(0, 110)

# Slip
s = 0.2

# Solution

# Preliminars
phase_voltage = complex(line_voltage / np.sqrt(3), 0)  # Phase voltage
r_l = r_2 / s  # Load resistance
z_eq = r_1 + jx + r_l  # Equivalent impedance

# a) Rotor velocity
rotor_rpm = fn.rotor_velocity(s, field_rpm)

# b) Rotor current
i_r = phase_voltage / z_eq
i_r_polar = cmath.polar(i_r)

# c) Rotor power == output power
p_r = 3 * i_r_polar[0]**2 * r_l

# d) Torque
omega = rotor_rpm * (2 * np.pi / 60)  # rad/s
t = p_r / omega

# e) Motor efficiency
# Currents
i_f = phase_voltage / r_m  # Current through the core reactance
i_m = phase_voltage / jx_m  # Current through the core resistance
i_0 = i_f + i_m
i_en = i_0 + i_r  # Input current
i_en_polar = cmath.polar(i_en)

# Input power
p_en = 3 * np.real(phase_voltage) * np.real(i_en_polar) * fp
print(p_en)

# Efficiency
eta = (p_r / p_en) * 100

# __________________________________

# Print results
print(f"a) The rotor velocity is: {rotor_rpm} rpm")
print(f"b) The rotor current is: ({i_r_polar[0]} < {np.degrees(i_r_polar[1])}Â°) A")
print(f"c) The rotor power (output power) is: {p_r} W")
print(f"d) The rotor torque is: {t} Nm")
print(f"Current is: {i_en} A")
